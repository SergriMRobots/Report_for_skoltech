**Предыстория**
Главной задачей было внедрение в проект системы избежания столкновений, которая помогала бы в реальном времени в режиме телеуправления сохранить в целостности оборудование и обеспечить безопасность пациента при условии возможных ошибок оператора (не давать роботу сталкиваться с объектами при управлении джойстиком).

**Изначальный план и его изменение**
Изначально планировалось применить алгоритм на основе Artificial Potential Field, то есть добавить к end-effector отталкивающую силу при приближении к объектам, с которыми робот не должен столкнуться. Но, оказалось, что в этом случае на робота будут воздействовать нежелательные ускорения, мешающие правильно позиционировать робота. Поэтому было решено адаптировать метод threshold distance, реализованный в дефолтном moveit_servo из фреймворка Moveit и основанный на библиотеке FCL, под наши нужды. 

*Проблема 1*
При управлении джойстиком были замечены странности в поведении робота, а именно не всегда удавалось избежать коллизии. 

*Причина проблемы*
После долгих поисков причины было выдвинуто предположение о том, что алгоритм работает медленно. После этого, на Qt был написан виджет для замера времени действия библиотеки FCL и было выявлено, что время, затрачиваемое на необходимые рассчеты для избежания коллизий больше, чем необходимо для управления при частоте 125Гц, заложенной в робота. (про дефолтные 125 Гц мне сказали инженеры проекта)

**Как в общем работают алгоритмы избежания коллизий**
 1. Изначально строится AllowedCollisionMatrix -- матрица коллизий, которая говорит, между какими объектами потенциально могут произойти столкновения, а между какими нет. Это призвано снизить вычислительные затраты.
 2. Различными алгоритмами вычисляются расстояния между объектами, в соответствии с матрицей коллизий.
 3. Дальше среди этих расстояний выбирается минимальное и в зависимости от него мы уже можем судить, есть у нас коллизии или нет.

*Решение*
Необходимо было каким-либо образом ускорить вычисления расстояний, необходимых для избежания коллизий. После поиска было предложено два пути:
 1. Внедрение библиотеки Bullet
 2. Перенос вычислений на видеокарты nvidia с помощью cuRobo: CUDA Accelerated Robot Library
(спойлер: сработал первый способ, поэтому второй не нужно было реализовывать)

**Внедрение библиотеки Bullet**
После модификации исходного moveit_servo я смог добиться того, чтобы в проект легко встраивался новый способ избежания коллизий через ООП С++. Затем я внедрил библиотеку Bullet, уже модифицированную под ROS и замерил скорость выполнения рассчетов. Выйгрыш в скорости был x30, что позволяло уложиться в рамки частоты обновления 125 Герц.

*Проблема 2*

В некоторых положениях робота библиотеки FCL и Bullet на выходе давали  различные минимальные расстояния, необходимые для избежания коллизий. Также была очевидна ошибка в работе библиотеки Bullet -- нуль расстояния был неверным, на симуляции был виден существенный зазор между объектами.

*Причина проблемы*
Как выяснилось, Bullet плохо работает с объектами невыпуклой формы, 

*Решение*

Необходимо было модифицировать имеющиеся urdf файлы и collision matrix 





В проекте существовали решения, отличающееся от сырого [moveit_servo_vanila](https://github.com/moveit/moveit/tree/1.1.14/moveit_ros/moveit_servo) , в виде файлов *stop_distance_collision_check.cpp*, *threshold_distance_check.cpp* и модифицированного *collision_check.cpp*. Данные решения не удовлетворяли нашим требованиям по скорости или (в случае *stop_distance*) функциональности. После анализа кода и существующих решений было принято решение о попытке ускорения метода *threshold_distance* путем внедрения библиотеки bullet. 

Основной механизм работы кода -- домножение существующих скоростей на некий коэффициент *collision_scale*. Это происходит в файле *servo_calcs*
```
void ServoCalcs::applyVelocityScaling(Eigen::ArrayXd& delta_theta, double singularity_scale)
{
  ...
  double collision_scale = collision_checker_ ? collision_checker_->getScaleCoef(original_joint_state_, future_state) : 1.0;
  ...
}
```

Сущность *collision_checker* выбирается в этом же файле выше в соответствии с параметром *collision_check_type* в файле ur_config.yaml 

```
if (parameters_.check_collisions)
  {
    if (parameters_.collision_check_type == "threshold_distance")
       ...
    else if (parameters_.collision_check_type == "bullet_collision")
       ...
 }
```
По сути это и есть объект класса *CollisionCheck*, от которого наследуются все ответвления в виде *StopDistanceCollisionCheck*, *ThresholdDistanceCollisionCheck* и *BulletCollisionCheck*.

Во всех трех ответвлениях главная функция, которая должна быть реализована это *calcIteration*, которая возвращает число типа double -- коэффициент, на который будет домножаться скорость.
Эта функция вызывается в родительском методе 

```double CollisionCheck::getScaleCoef(const sensor_msgs::JointState& now, const sensor_msgs::JointState& future)
{
  if (use_collision_check)
  {
    ...
    auto scale = calcIteration(now, future); 
    ...
    return scale;
  }

```

**Bullet** 
1. Почему Bullet
2. Как реализован код
3. Какие подводные

   1. Bullet производит быстрое вычисление расстояний. Тесты показали, что в сравнении с *threshold_distance*, изначально взятой из FCL, Bullet в среднем был в 30 раз быстрее, что позволяет нам уложиться в 125 Hz для применения его в режиме реального времени.
   2. Собственно, Америку я не открывал и просто использовал [туториал](https://moveit.ros.org/bullet/collision%20detection/moveit/2020/11/18/bullet-collision.html) и [github](https://github.com/moveit/moveit/issues/2998). Конфигурацию файлов и настроек я сделал ровно такую же, как и у *threshold_distance*: то есть буквально делал поиск по файлам строчки "thresholddistance" и тд... и рядом добавлял настройки для своего класса Bullet, реализованного в */src/moveit_servo/src/bullet_collision.cpp*

      2.2 Для спинки кресла надо было сформировать в папке *tms_ur_description/addons* папку *chair*  и добавить

      ```
      <xacro:include filename="$(find tms_ur_description)/addons/chair/macros/chair_macro.xacro"/>
      ...
      <xacro:add_chair/>
      ```
      в файл */src/tms_ur_description/urdf/ur.xacro*

      2.3 Еще надо не забыть отключить нежелательные коллизии в файле */src/tms_ur5_series_moveit_config/config/ur5.srdf.xacro* чтоб у нас не считались расстояния между частями кресла или какие-то еще, которые мы не хотим

   3. Подводные оказались в том, что bullet плохо работает с невыпуклыми формами, поэтому сложные фигуры лучше или аппроксимировать более простыми или (как в случае со спинкой кресла) разбивать на меньшие части и собирать отдельно в urdf файле (смотри */src/tms_ur_description/addons/chair/macros/chair_macro.xacro*). То есть **невыпуклых форм в виде готовых stl файлов (как например старая версия base.stl) надо избегать**. Это оказалась известная проблема, но чтобы ее найти, потребовалось много времени [link](https://github.com/bulletphysics/bullet3/issues/1507) [link2](https://github.com/bulletphysics/bullet3/issues/2531)  

**Джойстик** 

В папке есть файл "порядок запуска узлов", но в нем пропущено что драйвер для джойстика надо брать по [ссылке](https://wiki.ros.org/spacenav_node), а не с офф. сайта компании-производителя. 

Еще хочу отметить, необходимость подготовки робота в UrSim перед использованием:

"URSim при запуске устанавливает робота в одно и то же (не самое удачное) положение и оно не подходит по локтевому шарниру в заданные лимиты из joint_limits.yaml, поэтому желательно через полископ вручную переводить робота в валидное положение (например, q1="90" q2="-90" q3="90"  q4="-90" q5="-90" q6="0") и уже дальше работать "






